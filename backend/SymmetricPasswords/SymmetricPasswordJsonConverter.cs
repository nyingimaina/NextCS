using System;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Security.Cryptography;
using System.IO;

namespace SymmetricPasswords;

public class SymmetricPasswordJsonConverter : JsonConverter<string>
{
    // WARNING: These keys are hardcoded and insecure. This is for demonstration
    // purposes only, as requested. In a real application, retrieve these
    // from a secure location.
    private static readonly byte[] key = Encoding.UTF8.GetBytes("BananaBredKey123");
    
    // A prefix to identify encrypted strings and avoid heuristics.
    private const string EncryptedPrefix = "ENC:";

    public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        if (string.IsNullOrEmpty(value))
        {
            return string.Empty;
        }

        return DecryptValue(value);
        
    }

    public string DecryptValue(string value)
    {
        if (value.StartsWith(EncryptedPrefix, StringComparison.Ordinal))
        {
            try
            {
                var ciphertextWithIV = value.Substring(EncryptedPrefix.Length);
                return Decrypt(ciphertextWithIV);
            }
            catch (FormatException)
            {
                // This indicates the string is not a valid Base64 string.
                // It was likely a plain text value that happened to start with "ENC:".
                // We'll treat it as a cleartext value by falling through.
                return value;
            }
            catch (CryptographicException)
            {
                // Indicates decryption failed. It was likely corrupted or not a valid ciphertext.
                // Treat it as a plain text value.
                return value;
            }
            catch (Exception ex)
            {
                // Log and re-throw other unexpected exceptions if needed.
                // For this scenario, we'll just return the original value.
                Console.WriteLine($"Unexpected decryption error: {ex.Message}");
                return value;
            }
        }

        // If it doesn't have the prefix, treat it as cleartext.
        return value;
    }

    public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
    {
        if (string.IsNullOrEmpty(value))
        {
            writer.WriteStringValue(string.Empty);
            return;
        }

        try
        {
            var encrypted = Encrypt(value);
            writer.WriteStringValue(EncryptedPrefix + encrypted);
        }
        catch (CryptographicException ex)
        {
            // If encryption fails, log the issue and fall back to cleartext.
            // This prevents data loss but exposes the password. This is a trade-off.
            Console.WriteLine($"Encryption failed. Writing cleartext. Error: {ex.Message}");
            writer.WriteStringValue(value);
        }
        catch (Exception ex)
        {
            // Log and handle other exceptions during encryption.
            Console.WriteLine($"Unexpected encryption error: {ex.Message}");
            writer.WriteStringValue(value);
        }
    }

    private static string Encrypt(string plainText)
    {
        using var aes = Aes.Create();
        aes.Key = key;
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;
        
        // A new, random IV is generated by Aes.Create() and can be accessed via aes.IV.
        // This is a crucial security improvement.
        var encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

        using var memoryStream = new MemoryStream();
        // Prepend the IV to the output stream.
        memoryStream.Write(aes.IV, 0, aes.IV.Length);

        using var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
        using var streamWriter = new StreamWriter(cryptoStream);
        
        streamWriter.Write(plainText);
        streamWriter.Flush();
        cryptoStream.FlushFinalBlock();
        
        return Convert.ToBase64String(memoryStream.ToArray());
    }

    private static string Decrypt(string cipherTextWithIV)
    {
        var fullCipherBytes = Convert.FromBase64String(cipherTextWithIV);

        // Separate the IV from the actual ciphertext.
        var ivBytes = new byte[16]; // AES block size is 16 bytes
        Array.Copy(fullCipherBytes, 0, ivBytes, 0, 16);

        var cipherBytes = new byte[fullCipherBytes.Length - 16];
        Array.Copy(fullCipherBytes, 16, cipherBytes, 0, cipherBytes.Length);

        using var aes = Aes.Create();
        aes.Key = key;
        aes.IV = ivBytes; // Use the extracted IV
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;

        var decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
        
        using var memoryStream = new MemoryStream(cipherBytes);
        using var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
        using var streamReader = new StreamReader(cryptoStream);

        return streamReader.ReadToEnd();
    }
}